#ifndef __GLVIEW__
#define __GLVIEW__

#define NOMINMAX

#include <Carbon/ShaderProgram.h>
#include <Carbon/Texture.h>
#include <Carbon/Buffer.h>
#include "Enum.h"

#include <glm.hpp>
#include <gtc/matrix_transform.hpp>
#include <e3/Types.h>
/*#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>*/

#include <functional>
#include <algorithm>

#include <Yoga.h>
#include "ApplicationSharedData.h"

namespace e3 {

    class Activity;

    typedef std::function<void(void)> OnClickCallback;
    typedef std::function<void(void)> OnFocusOutCallback;

    enum class GLViewSize {
        FillParent = 0xFFFFFF
    };

    struct GLSize {
        float width;
        float height;
    };




    struct ShadowRenderParams {
        glm::mat4 Scale;
        glm::mat4 Translate;
        glm::vec4 UVXScale;
        glm::vec4 UVYScale;
    };

    struct BloomParams {
        int BlurSize;
    };




    class View {
    public:
        View();

        virtual ~View();

        void setParent(View *pParent) {
            mParent = pParent;
            mRect.width = std::min((float) mRect.width, mParent->width());
            mRect.height = std::min((float) mRect.height, mParent->height());
        }

        View *getParent() { return mParent; }

        int id() { return mId; }

        void setId(int id) { mId = id; }

        void SetUsrPtr(void* pUsrPtr) { mUsrPtr = pUsrPtr; }
        void* GetUsrPtr() { return mUsrPtr; }

        float width() { return /* mImage.width;*/ mRect.width; }

        float height() { return /*mImage.height;*/mRect.height; }

        e3::Rect2f rect() { return mRect; }
        e3::Rect2f GetGeometry()
        {
            e3::Rect2f rect = mRect;
            glm::vec4 pos(mRect.x, mRect.y, 0.0f, 1.0f);
            const glm::mat4& keyboardTransform = ApplicationSharedData::Get()->GetKeyboardTransform();
            pos = keyboardTransform * mAdditionalTransform.Translate * pos;
            rect.x = pos.x;
            rect.y = pos.y;
            return rect;
        }

        EViewType Type() { return mType; }

        void SetViewType(EViewType type) { mType = type; }

        void SetZ(float z) { mZ = z; }

        float GetZ() { return mZ; }

        virtual float GetMaxZ();

        void setWidth(float width);

        void setHeight(float height);

        void SetMinHeight(float height);

        void SetMaxHeight(float height);

        void SetMinWidth(float width);

        void SetMaxWidth(float width);

        void setPosition(float x,
                         float y) { /*mPosition = glm::vec2(x, y);*/ /*mRect.x = x; mRect.y = y;*/
//        YGNodeStyleSetPosition(mNode, YGEdgeLeft, x);
//        YGNodeStyleSetPosition(mNode, YGEdgeTop, y);
        }

        glm::vec2 position() { return /*mPosition;*/glm::vec2(mRect.x, mRect.y); }

        void SetBorderSize(float borderSize) { mBorderSize = borderSize; }

        void SetBorderColor(const glm::vec3 &color);

        void SetBorderColor(const glm::vec4 &color);

        void SetBorderType(EBorderType type);

        void SetPadding(float padding) { YGNodeStyleSetPadding(mNode, YGEdgeAll, padding); }
        float GetPaddingTop() {
            float padding = YGNodeStyleGetPadding(mNode, YGEdgeTop).value;
            if (isnan(padding))
            {
                padding = YGNodeStyleGetPadding(mNode, YGEdgeAll).value;
            }
            return isnan(padding) ? 0 : padding;
        }

        float GetPaddingBottom() {
            float padding = YGNodeStyleGetPadding(mNode, YGEdgeBottom).value;
            if (isnan(padding))
            {
                padding = YGNodeStyleGetPadding(mNode, YGEdgeAll).value;
            }
            return isnan(padding) ? 0 : padding;
        }

        virtual void SetBorderRadius(float radius) {
            mBorderRadius = glm::vec4(radius);
            if (mBorderRadius != glm::vec4(0)) {
                mShapeType = EShapeType::Circle;
            }
        }

        virtual void SetBorderRadius(const glm::vec4 &radius) {
            mBorderRadius = radius;
            if (mBorderRadius != glm::vec4(0)) {
                mShapeType = EShapeType::Circle;
            }
        }

        void setGravityHor(EGravity gravity);

        EGravity gravityHor() { return mGravityHor; }

        void setGravityVer(EGravity gravity);

        EGravity gravityVer() { return mGravityVer; }

        virtual void SetShapeType(EShapeType type);

        void setBackgroundColor(const glm::vec3 &color);

        void setBackgroundColor(const glm::vec4 &color);

        void SetBackgroundColorFocused(const glm::vec3 &color);

        void SetBackgroundImagePath(const std::string &path);

        void SetBackgroundImage(int id);

        void SetBackgroundImageOpacity(float opacity) { mBackgroundImageOpacity = opacity; }

        void SetBackgroundImageUrl(const std::string &url);
        void SetBackgroundImageUrl(const std::string &url, const std::vector<std::string>& headers);

        void
        SetBackgroundSize(e3::EBackgroundSize backgroundSize) { mBackgroundSize = backgroundSize; }

        void SetBackgroundPosition(
                e3::EBackgroundPosition backgroundPosition) { mBackgroundPosition = backgroundPosition; }

        void SetScaling(e3::EScaling scaling);

        void SetShadow(const e3::ShadowParams &shadowParams) {
            if (!mShadowParams) mShadowParams = new e3::ShadowParams();
            mShadowParams->Color = shadowParams.Color;
            mShadowParams->BlurSize = shadowParams.BlurSize;
            mShadowParams->Offset = shadowParams.Offset;
        }

        void SetBloom(const e3::BloomParams &bloomParams) {
            if (!mBloomParams) mBloomParams = new e3::BloomParams();
            mBloomParams->BlurSize = bloomParams.BlurSize;
        }

        virtual void DrawShadow() {};

        virtual void DrawBloom() {
            mDrawBloom = false;
            mDrawShadow = false;
            if (mBloomParams) draw();
            mDrawBloom = true;
            mDrawShadow = true;
        };

        virtual void draw() = 0;

        virtual void update();

        void setOnClickCallback(OnClickCallback callback) {
            mOnClickCallback = callback;
        }

        void setOnFocusOutCallback(OnFocusOutCallback callback) {
            mOnFocusOutCallback = callback;
        }

        bool HasOnClickCallback() { return mOnClickCallback != nullptr; }

        void SetVisibilityInternal(EVisibility visibility) { mVisibility = visibility; }

        EVisibility GetVisibilityInternal() { return mVisibility; }

        void SetVisibility(EVisibility visibility);

        EVisibility Visibility() { return mVisibility; }

        void SetMarginTop(int margin);

        void SetMarginBottom(int margin);

        void SetMarginLeft(int margin);

        void SetMarginRight(int margin);

        void SetAspectRatio(float aspectRatio);

        virtual bool onClick(const glm::vec2 &pos);
        virtual bool OnMouseDown(const glm::vec2 &pos) { return true; }
        virtual bool OnPointerUp(const glm::vec2 &pos) { SetState(EViewState::Initial); return true; }

        virtual void onMove(const glm::vec2 &distance, const glm::vec2 &pos) {}

        static View *focusedView() { return sFocusedView; }

        virtual void Focus() {
            mFocused = true;
            //  if (mOnClickCallback) mOnClickCallback();
            sFocusedView = this;
            if (mBackgroundColorFocused.w) {
                mBackgroundColorCurrent = mBackgroundColorFocused;
            }
        }

        virtual void Unfocus() {
            if (sFocusedView == this) {
                sFocusedView = nullptr;
            }
            mBackgroundColorCurrent = mBackgroundColor;
            if (mOnFocusOutCallback) mOnFocusOutCallback();
            mFocused = false;
        }

        virtual Activity *GetActivity()
        {
            return ApplicationSharedData::Get()->GetContext()->GetActivity();
//            return mParent ? mParent->GetActivity() : nullptr;
        }

        virtual void SetScrollDirection(float value, EOrientation orientation) {
            std::lock_guard<std::mutex> l(e3::ApplicationSharedData::Get()->GetScrollMutex());
            switch (orientation) {
                case EOrientation::Vertical:
                    mSelfScrollDirection.y = value;
                    return;
                default:
                    mSelfScrollDirection.x = value;
            }
        }

        e3::Transform &GetTransform() { return mTransform; }

        const glm::vec4 &GetBackgroundColor() { return mBackgroundColor; }

        void SetPositionType(e3::EPositionType positionType);

        e3::EPositionType GetPositionType() { return mPositionType; }

        float GetTop();

        void SetTop(float value);

        float GetBottom();

        void SetBottom(float value);

        float GetLeft();

        void SetLeft(float value);

        void SetRight(float value);

        virtual void Translate(const glm::vec3 &direction) {
            mAdditionalTransform.Translate = glm::translate(mAdditionalTransform.Translate,
                                                            direction);
        }

        virtual void Scale(const glm::vec3 &direction) {
            glm::mat4 scale = glm::scale(glm::mat4(1), direction);
            mAdditionalTransform.Scale = scale * mAdditionalTransform.Scale;
        }

        virtual void SetScale(const glm::vec3 &direction) {
            mAdditionalTransform.Scale = glm::scale(glm::mat4(1), direction);
        }

        virtual void SetTranslation(const glm::vec3 &direction) {
            mAdditionalTransform.Translate = glm::translate(glm::mat4(1), direction);
        }

        virtual void SetTranslation(float value, EOrientation direction) {
            glm::vec4 vec(0.0f, 0.0f, 0.0f, 1.0f);
            vec = mAdditionalTransform.Translate * vec;
            if (direction == EOrientation::Vertical) vec.y = value;
            else vec.x = value;
            mAdditionalTransform.Translate = glm::translate(glm::mat4(1), glm::vec3(vec));
        }

        const glm::mat4 &GetTranslation() const {
            return mAdditionalTransform.Translate;
        }

        int GetIndex() { return mIndex; }

        void SetIndex(int index) { mIndex = index; }

        virtual void setOpacity(float opacity) { mOpacity = opacity; }

        float getOpacity() { return mOpacity; }

    public:
        static void SetScreenWidth(float width) { sScreenWidth = width; }

        static void SetScreenHeight(float height) { sScreenHeight = height; }

        YGNodeRef Node() { return mNode; }

        void SetState(EViewState state) { mState = state; }
        EViewState GetState() { return mState; }

        bool GetDrawShadow() { return mDrawShadow; }
        void SetDrawShadow(bool drawShadow) { mDrawShadow = drawShadow; }

    protected:
        View *mParent = nullptr;

        int mId = -1;
        // GLSize mFixedSize;
        // GLSize mFixedWeight;

        OnClickCallback mOnClickCallback = nullptr;
        OnFocusOutCallback mOnFocusOutCallback = nullptr;

        e3::Rect2f mRect;
        e3::Transform mTransform;
        e3::Transform mAdditionalTransform;
        bool mForcedWidth = false;
        bool mForcedHeight = false;
        EGravity mGravityHor = EGravity::Center;
        EGravity mGravityVer = EGravity::Center;

        float mBorderSize = 0.0f;
        glm::vec4 mBorderColor;
        EBorderType mBorderType = EBorderType::Unknown;
        glm::vec4 mBorderRadius = glm::vec4(0);
        e3::EScaling mScaling = e3::EScaling::None;

        EShapeType mShapeType = EShapeType::Rectangle;
        glm::vec4 mBackgroundColorCurrent;
        glm::vec4 mBackgroundColor;
        glm::vec4 mBackgroundColorFocused;
        Texture *mBackgroundImage = nullptr;
        float mBackgroundImageOpacity = 1.0;
        e3::EBackgroundSize mBackgroundSize = e3::EBackgroundSize::Contain;
        e3::EBackgroundPosition mBackgroundPosition = e3::EBackgroundPosition::Center;
        e3::ShadowParams *mShadowParams = nullptr;
        e3::ShadowRenderParams *mShadowRenderParams = nullptr;

        e3::BloomParams *mBloomParams = nullptr;
        bool mDrawBloom = true;
        bool mDrawShadow = false;

        glm::mat4 mTranslate = glm::mat4(1);
//    glm::mat4 mScrollTransform = glm::mat4(1);
        glm::vec2 mChildrenScrollDirection = glm::vec2(0);
        glm::vec2 mSelfScrollDirection = glm::vec2(0);

        static float sScreenWidth;
        static float sScreenHeight;

        static View *sFocusedView;
        EViewType mType = EViewType::Unknown;
        bool mFocused = false;

        EVisibility mVisibility = EVisibility::Visible;

        YGNodeRef mNode = nullptr;
        bool mFirstFrame = true;

        float mZ = 0.0f;
        float mAspectRatio = 0.0f;
        float mOpacity = 1.0f;
        e3::EPositionType mPositionType = e3::EPositionType::Relative;
        int mIndex = -1;

        void* mUsrPtr = nullptr;

        EViewState mState = EViewState::Initial;
    };
}
//struct Style
//{
//    EGravity    GravityHor;
//    EGravity    GravityVer;
//    glm::vec4   BorderColor;
//    EBorderType BorderType;
//    glm::vec4   BackgroundColor;
//    EShapeType  ShapeType;
//    int         FontSize;
//
//};

#endif // __GLVIEW__
